\documentclass[runningheads,envcountsame,a4paper]{llncs}
\pdfpagesattr{/CropBox [92 112 523 778]}

\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage[algoruled,linesnumbered,noend]{algorithm2e}
\usepackage{ifdraft}
\usepackage{enumitem}
\usepackage{cite}
\usepackage{multirow}
\usepackage{url}
\usepackage{xspace}
\usepackage{graphicx}

\newcommand{\coll}[1]{\url{#1}}

% REMOVE BEFORE SUBMISSION - begin part
\usepackage{verbatim}
\newcommand{\nota}[1]{%
  {\sffamily\bfseries #1}%
  \marginpar{\framebox{\Large *}}%
}
\newcommand{\notaestesa}[2]{%
  {\sffamily {\bfseries #1}{\footnotesize #2}}%
  \marginpar{\framebox{\Large *}}%
}

% \usepackage{tikz}
% \usetikzlibrary{shapes,arrows}
% \usetikzlibrary{snakes}
% \usetikzlibrary{positioning,patterns}


\newcommand{\mathfrc}[1]{\text{\fontfamily{frc}\selectfont#1}}

\usepackage{booktabs}
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\newcommand{\lmidrule}{\midrule[.4\heavyrulewidth]}
\usepackage{tabularx}
\newcolumntype{T}[1]{>{\tsize} #1}
\newcolumntype{W}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\usepackage{array}


\newcommand{\inputdata}[1]{\noindent \emph{Input: }#1\\*}
\newcommand{\outputdata}[1]{\noindent \emph{Output: }#1\\}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\ie}{\textit{i.e.}\xspace}
\newcommand{\st}{s.t.\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\renewcommand{\l}{\ensuremath{\ell}}
\renewcommand{\emptyset}{\ensuremath{\varnothing}}


\begin{document}

\title{Assembling of  string graphs by a lightweight BWT}

\author{%
  Paola Bonizzoni \and
  Gianluca Della Vedova \and
  Yuri Pirola \and
  Marco Previtali \and
  Raffaella Rizzi
}
\authorrunning{Bonizzoni \etal}

% \institute{DISCo,
%   Univ. Milano-Bicocca,
%   Milan, Italy\\ \email{\{beretta,bonizzoni,rizzi\}@disco.unimib.it}
% \and Dip. Statistica, Univ. Milano-Bicocca,
%   Milan, Italy\\ \email{gianluca.dellavedova@unimib.it}
% }

\maketitle

\begin{abstract}


\end{abstract}

\section{Introduction}
De novo sequence assembly is a difficult problem and is a necessary step
in analyzing data from next generation sequencing technologies (NGS).
NGS produce from a (genomic or transcriptomic) sequence a huge amounts
of short sequences, called reads.
Usually reads are compared to produce a graph representation from which
derive a path representing the original sequenced sequence.
Such a graph representation may be derived by overlap-based methods or
building De Bruijn graphs~\cite{Zerbino2008, Simpson2009, Peng2010}.
Overlap-based methods are based on computing pairwise overlaps among
reads and then representing reads as vertices and edges connect
overlapping reads, where each edge $(r,r')$ may be labeled by the suffix
of $r'$ that exceeds the overlap between the two reads.
However, they require a comparison among reads that is quadratic in the
total size of the input data.
These method are of particular interest in genome assembly since it
applies to mixed length reads of coming from different next generation
sequencing technologies.

Recently~\cite{Simpson2010, Simpson2012} have proposed string graphs as
an alternative approach to de novo genome assembly based on De Bruijn
graphs.
The main formulation was proposed by Gene Myers~\cite{Myers2005}.
The method builds a graph from reads that is obtained by building an
overlap graphs and then implementing transitive reduction to produce a
string graph where only maximal overlaps are considered.
More precisely, given a path $r \rightarrow r_1 \rightarrow r_2$ in a
overlap graph, and given the \emph{transitive} edge $r \rightarrow r_2$,
Simpson and Durbin~\cite{Simpson2010} observe that (under the assumption
of forbidding the substring property) the string associated to edge $(r,
r_1) $ is a prefix of the string associated to the transitive edge $(r,
r_2)$.
Based on this property, Simpson and Durbin~\cite{Simpson2010} define a
notion of \emph{irreducible} edge and show how to construct a string
graph by outputting directly irreducible edges (instead of building an
overlap-graph) significantly shrinking memory requirements and reducing
compute time to be linear in the total size of the input data.
The reduction in time and space in the string graph assembly
problem~\cite{Simpson2010} is achieved by making use of an
implementation of the problem by BWT and the FM-index apparatus.
In their works, Simpson and Durbin pose the question of further reducing
the space requirements in solving the string graph assembly by an
external memory construction of the FM-index.
In the meantime, an investigation of external memory construction of the
BWT has been started in~\cite{Bauer2011} showing that it is possible to
arbitrarily reduce the use of RAM for building a BWT and for solving
typical applications of the BWT \notaestesa{Raffa}{Aggiungere rif biblio}.
\notaestesa{Raffa}{altri rif a BWT in memoria esterna sono Ferragina2012,
Bauer2013}.
In this paper, based upon the work in~\cite{Bauer2011}, we show how to
construct the string graph from a BWT for a collection of reads that is
completely in external memory.

The construction of the String graph in~\cite{Simpson2010} works in two
steps.
In the first one, for each read $r$ in the collection $R$, the position
in the BWT ($Q$-interval) of reads that share with $r$ an overlap given
by a string $Q$ are computed in time linear in the size of $r$.
In the second step, $Q$-intervals are extended to discover irreducible
edges.
Both steps strictly require to keep the whole FM-index and BWT sequence
for $R$ and for the collection of reversed reads in main memory since
the $Q$-intervals and the relative extensions cover different positions
of the whole BWT.
Moreover, the algorithm requires to recompute $Q$-intervals a number of
times that is equal to the number of different reads in $R$ share the
string $Q$ as a suffix.


In our approach, we keep the BWT for the collection $R$ of reads and its
reverse version, $R'$ in secondary memory and we read them sequentially,
and during this process we iteratively forward and backward extend each
$Q$-interval computed at a previous iteration.
Each iteration may produce irreducible edges that we keep in RAM.
%terminal extension pairs and we keep in RAM the String Graph for the
%subset of reads in  $R$ for which at least a $q'$-interval is in a
%terminal extension pair computed so far. More precisely, at a
%given iteration $i$, given $\mathcal{E}_i$  the terminal extension
%pairs at step $i$, if $R_i$ is the subset of reads which at least a
%$q'$-interval is in  extension pair of
%$\mathcal{E}_i$, then the algorithm produces the String graph over
%$R_i$ since only extensions that are prefix-free for sets $E(r)$, with
%$r \in R_i$ have been examined.




--------- non so dove vada-----------------


A key observation in our work is the fact that due to the fact that a
BWT consists of the symbols that precedes the lexicographic ordering of
suffixes of the reads of a collection, it is possible to "walk"
consecutively on the BWT of the collection of reads and of the reversed
version of the reads and then building a forward and backward extension
of a $Q$-substring by symbols of the alphabet lexicographically ordered.
All this can be done entirely using files for each symbol of the
alphabet and files for the BWT and its reversed version.

% and by using the RAM only to keep an indexed representation of the
% string graph


\begin{comment}
descrizione The FM-index .... [inserire citazione FM-index]

With the advent of NGS data, the investigation of the BWT has moved
towards its use in indexing huge collections of texts, represented by
the reads of variable length.
The notion of Extended Borrows Wheeler has been proposed to deal with a
collection of texts~\cite{Bauer2011} and its potentiality in
Bioinformatics to index read data has been investigated in ....

While the BWT has been deeply used for the alignment of reads to a
reference genome, for the first time the BWT has been explored as a tool
for de novo assembly.

In~\cite{Simpson2010} Durbin addresses the problem of having a more
efficient space FM-index implementation of the string graph problem.

---results----

\end{comment}


\section{Preliminaries}
Let $\Sigma = \{\sigma_1, \cdots, \sigma_m\}$ be an ordered finite
alphabet.
Given a string $r = a_1 \cdots a_l$, by $r[i]$ we denote the $i$-symbol
$a_i$ of $r$ and by $r[i,k]$, with $i \leq k$ we denote the substring
$a_i \cdots a_k$ of string $r$.
Then $|r|$ is the length of string $r$.
The \emph{reverse} of a string $r = a_1 \cdots a_l$, denoted as $rev(r)$,
consists of the string $r' = a_l \cdots a_1$ obtained by reading $r$
from right to left.

The \emph{suffix} starting in position $i$ of $r$, in short $i$-suffix of $r$, is
the substring $r[i, l]$.
The suffix and \emph{prefix} of length $k$ of string $r$ are the
substrings $r[l-k +1, l]$ and $r[1, k]$ respectively of string $r$.

Let $R = \{r_1, \cdots, r_n\}$ be a collection of $n$ strings over
$\Sigma$, where each sequence $r_i$ ends with a sentinel symbol \$
that is not in the alphabet $\Sigma$ and is lexicographically lower than
any other symbol in $\Sigma$.
Let $SA(R)$ be the \emph{generalized suffix-array} for the set $R$
where each element $SA(R)[i]= (k, j)$ if and only if the
$k$-suffix of string $r_{j}$ is the $i$-th lowest suffix of some string in $R$, according to the
lexicographic.
The generalized suffix-array is an indexing data structure for a
collection of strings~\cite{Shi1996}.

Then the BWT of the collection $R$ is defined as the sequence $B_R$ such
that $B_R[i]=r_{j}[k -1]$ if $k > 1$ and $SA[i] = (k,j)$, otherwise
$B_R[i]= $ \$.
Informally, $B_R[i]$ is the symbol that precedes the $k$-suffix of
string $r_j$ where such suffix is the $i$-th lowest in the ordering of
the generalized suffix array $SA$.
Clearly, the size of the suffix array is the sum of the length of all
strings in the collection $R$, that is $N =
\sum_{i \leq n}|r_i|$.
Since $B_R$ is a permutation of the concatenation of the strings in $R$,
the notion of FM-index~\cite{Ferragina2000} can be extended to a BWT of
the collection $R$.
The arrays that constitute the FM-index are defined as usual: $C(\sigma, R)$ denotes the
number of symbols in $R$ that are lexicographically smaller than the symbol
$\sigma$, while $Occ(\sigma, i, R)$ is the array that reports the number
of occurrences in $B_R[1, i]$ of the symbol $\sigma$ -- notice that $\sigma$ may be the sentinel \$.

%Now, the string $B[i,k]$ for indexes $1 \leq i \leq k \leq N$ reports
%the sequence of symbols that precedes the ordered suffices in the
%generalized  suffix array $SA[i,k]$.

The two arrays $C(\sigma, R)$ and $Occ(\sigma, i, R)$, together with the string $B_{R}$ allow to
compute all occurrences of a string $Q$ in a
collection $R$ of strings, using the backward extension algorithm~\cite{Ferragina2000}.

% Observe that the string $B[i,k]$ for indexes $1 \leq i \leq k \leq N$
% reports the sequence of symbols that precedes the ordered suffices in
% the generalized suffix array $SA[i,k]$.






\subsection{Forward and backward extension of $Q$-intervals}

In the following let $B$ be the BWT for the collection $R$.
Moreover, let $B'$ be the BWT of the set $R'$ of the reversed reads,
that is $R' = \{ rev(r): r \in R\}$.
We are especially interested into some substrings or \emph{intervals} of $B$ that are identified by
a string $Q$.
In this case we will say that the \emph{$Q$-interval} of $B$ is the substring $B[b, e -1]$
consisting of the symbols that precede the string $Q$ in any string of $R$.
Equivalently the $Q$-interval is equal to the maximal interval $[b, e)$ such that
$Q$ is a prefix of all suffixes in the interval $SA[b, e-1]$.
We define the \emph{length} of a $Q$-interval as the length of
the string $Q$, and the \emph{width} of a $Q$-interval $[b, e)$ as the
difference $(e-b)$.
A $Q$-interval on $B$ of width larger than $1$ represents a string $Q$
that occurs more than once in $R$.
Whenever $Q$ begins with a $\$$, the $Q$-interval is also called a \emph{$\$$-interval}.
In the following, given an interval $q=[b,e)$, we denote with $R(q)=R(b,e)$ the reads containing the
BWT symbols of $B[b, e-1]$.

The pattern matching algorithm using the FM-index is based on the idea of backward extension~\cite{Ferragina2000},
and it can be stated as a progressive refinement of a $Q$-interval by adding a new symbol to the beginning of $Q$.
More formally, given a $Q$-interval $[b,e)$ and a symbol $\sigma \in \Sigma$, the backward
extension of $[b,e)$ with $\sigma$ (or \emph{backward
$\sigma$-extension}) is the $\sigma Q$-interval $[b_{\sigma},e_{\sigma})$
-- notice that the $\sigma Q$-interval also represents the  suffixes starting with
the string $\sigma Q$. The interval $[b_{\sigma},e_{\sigma})$ can be quickly computed
from $[b,e)$ using the FM-index arrays $C(\sigma,R)$ and
$Occ(\sigma, i, R)$, since the width $(e_{\sigma}-b_{\sigma})$ of the $\sigma Q$-internal is equal
to the number of occurrences of  $\sigma$ in $B[b,e-1]$, that is $Occ(\sigma, e, R)-Occ(\sigma, b, R)$.
In the following,
we say that a  $Q$-interval $[b,e)$, with a backward $\sigma$-extension $[b_{\sigma},e_{\sigma})$, also has $(e_{\sigma}-b_{\sigma})$ possible backward
extensions with $\sigma$.
Given a $Q$-interval $q=[b,e)$ we denote with $X(q)$ (or $X(b,e)$)
the set of all  backward $\sigma$-extensions of $q$, that is $X(q)=\{ \sigma Q\text{-interval}: \sigma\in\Sigma\}$.
Similarly, the forward extension of a $Q$-interval $[b,e)$ with the symbol
$\sigma$ (or  \emph{forward $\sigma$-extension}) is the
$Q \sigma$-interval $[b^f_{\sigma},e^f_{\sigma})$ -- the forward extension represents the suffixes
starting with $Q \sigma$. In the following, we say that a
$Q$-interval $[b,e)$ with  a forward $\sigma$-extension
$[b^f_{\sigma},e^f_{\sigma})$ has $(e^f_{\sigma}-b^f_{\sigma})$
possible forward extensions with $\sigma$. Notice that the interval
$[b^f_{\sigma},e^f_{\sigma})$ is contained in $[b,e)$, but it is not as easy to compute as the corresponding backward extension.


\begin{definition}
\label{def:linked-intervals}
Let  $Q=rev(Q')$.
Then the $Q$-interval $[b,e)$ on $B$ and the $Q'$-interval $[b',e')$ on $B'$ are
\emph{linked}.
\end{definition}

Clearly each $Q$-interval on $B$ is linked with exactly one $Q'$-interval on $B'$.
Moreover, two linked intervals have same width and length, hence $(e-b)=(e'-b')$~\cite{Lam2009,Simpson2010}.
Notice that when the length of the linked intervals is $1$ (\ie $Q=rev(Q)=\sigma$), then $[b,e)=[b',e')$,
since the two FM-index functions $C(\sigma, R)$ and $C(\sigma, R')$ are the same.
In fact, the set of symbols of $R$ is equal to the set of symbols of $R'$.
It is possible to show that, given two linked intervals $[b,e)$ and $[b',e')$, even the backward $\sigma$-extension $[b_{\sigma},e_{\sigma})$ of $[b,e)$ and the forward $\sigma$-extension $[b^{'f}_{\sigma},e^{'f}_{\sigma})$ of $[b',e')$ are linked intervals.
In fact, since the interval $[b_{\sigma},e_{\sigma})$ is a $\sigma Q$-interval and the interval $[b^{'f}_{\sigma},e^{'f}_{\sigma})$ is a $rev(Q) \sigma$-interval, then they are linked by Definition~\ref{def:linked-intervals}.
Moreover, the number of possible backward extensions with $\sigma$ of $[b,e)$ is equal to the number of possible forward extensions with $\sigma$ of $[b',e')$.
Also,  the start $b^{'f}_{\sigma}$ is given by adding to $b'$ the number of symbols that are smaller than $\sigma$ and are in $B[b,e-1]$,
while the end $e^{'f}_{\sigma}$ is given by adding to $b^{'f}_{\sigma}$ the number of symbols $\sigma$ which are in $B[b,e-1]$~\cite{Simpson2010}.

\begin{proposition}
\label{proposition:linked-intervals}
Let $B$ and $B'$ be respectively the BWT of a text $T$ and $rev(T)$, let $Q$ be a substring of $T$ and let $\sigma$ be a symbol.
Let $[b,e)$ be the $Q$-interval on $B$.
Then it is possible to compute in $O(1)$ time the $\sigma Q$-interval on $B$ and the $rev(Q) \sigma$-interval on $B'$
using only of the FM-index functions $C(\sigma, R)$ and $Occ(\sigma, i, R)$.
\end{proposition}

A special case of this argument applies when
$Q$ is a prefix of $\alpha > 0$ reads in $R$.
In this case, the $Q$-interval $[b,e)$ has $\alpha$ possible backward $\alpha$-extensions, and  $B[b,e-1]$ contains $n$ $\$$s.
At the same time, the $\$ Q$-interval (\ie the backward $\$$-extension of $[b,e)$) represents the set of $\alpha$ reads with prefix $Q$.
Hence the $rev(Q)$-interval $[b',e')$ (linked to $[b,e)$) has $\alpha$ forward $\$$-extensions.
Finally, since $\$$ is the smallest symbol of $\Sigma$, the $rev(Q) \$$-interval is $[b',b'+\alpha)$.


%When a substring $Q$ occurs $m>0$ times as a suffix in $R$, then the
%$rev(Q)$-interval on $B'$ contains $m>0$ symbols $\$$, and the $\$
%rev(Q)$-interval represents the set of the $m$ reads %where $Q$ occurs
%as a suffix.

%\begin{definition}
%A \emph{S-interval} is a $rev(Q)$-interval $[b',e')$ on $B'$ having
%$m>0$ backward extensions with symbol $\$$  ($m$ is called the
%\emph{dimension} of the \emph{S-interval}).
%\end{definition}

Our procedure will compute the arc set $A_r$ of all outgoing arcs for each read $r$,
by building all possible $Q$-intervals that might be overlaps of two
reads in $R$, and then iteratively forward extending only the $Q$-intervals that
are prefixes of some read $r_{e}$ until the sentinel symbol \$ is
found (\ie the read $r_{e}$ has been completely read).
In any instant, for each read $r$ only one extension $r_{e}$ is stored; in fact after examining a $Q$-interval, the read $r_{e}$ is update, if necessary.



Two parts of the algorithm exploit the FM-index to perform
backward extensions to determine the intervals of overlapping
prefixes and forward extensions to extend those prefixes and build the
terminal extensions.


\section*{Building the String Graph}

The notion of String Graph~\cite{Simpson2010} leads to new approaches to design assembly algorithms.
More precisely, given a collection $R$ of strings, the string graph of $R$ is a directed graph whose vertices are the strings in $R$ and two reads $(r_{1}, r_{2})$ form an arc if $r_{1}$ and $r_{2}$ overlap.
We say that $r_1$ and $r_2$
\emph{overlap} if a suffix $\alpha$ of $r_1$ is also a prefix of $r_2$.
In this case,
$r_2$ \emph{extends} $r_1$ by $|r_2|- |\alpha|$ symbols, and $\alpha$ is the overlap of $r_{1}$ and $r_{2}$.
Moreover,
the suffix $\beta$ such that $r_2 = \alpha \beta$ is called the
\emph{extension} of $r_1$ with $r_{2}$.

Since the main purpose of the String Graph is to assemble the reads into a genomic sequence, transitive arcs (that is arcs $(r_{1}, r_{2})$ such that there exists a second path from $r_{1}$ to $r_{2}$) are not useful and are therefore discarded.
In other words, the String Graph contains only \emph{irreducible} arcs.


Since the actual genomic sequence from which the reads are extracted is unknown, we need some simplifying assumptions.
The first assumption is that $R$ is made of \emph{prefix-free} strings, that is there are not two strings $r_{1}, r_{2}\in R$ such that
$r_{1}$  is a prefix of  $r_{2}$.
The second assumption is that an arc $(r_{1}, r_{2})$ of the string graph exists only if the overlap of $r_{1}$ and $r_{2}$ is at least a certain constant $\tau$.



The construction of the String graph in~\cite{Simpson2010} works in two
steps.
In the first one, for each read $r$ in the collection $R$ all
$Q$-intervals, where $Q$ is the overlap of $r$ and some read extending $r$,
are computed in time linear in
the  length of $r$.
In the second step, each of these intervals are forward extended until
we find the first \$; such a $Q\alpha\$$-interval becomes an
irreducible edge.
Observe that the algorithm  in~\cite{Simpson2010} requires to keep the whole FM-index
and BWT sequence for $R$ and $R'$ in main memory, since it is impossible to
restrict in a portion of the BWT or of the FM-index the $Q$-intervals
and their extensions.
Moreover, the algorithm requires to recompute the $Q$-intervals a number of
times that is equal to the number of different reads in $R$ share the
string $Q$ as a suffix.\notaestesa{GDV}{ perchè?}


In our approach, we keep the BWT for the collection $R$ of reads and its
reverse version, $R'$ in secondary memory and we read them sequentially,
and during this process we iteratively forward and backward extend each
$Q$-interval computed at a previous iteration.
% Each iteration may produce some putative arcs and we keep in RAM
% the String Graph for the reads in $R$ appearing in
% $q_{2}'$-interval of a terminal extension pair computed so far.
% More precisely, at a given iteration $i$, let $\mathcal{E}_i$ denote the
% terminal extension pairs at step $i$, and let $R_i\subseteq R$ be the reads
% appearing as $q_{2}'$-interval  in an extension pair of $\mathcal{E}_i$.
\notaestesa{GDV}{ Non capisco le prossime due frasi}
Then the algorithm produces the String graph over $R_i$ since only
extensions that are prefix-free for sets $E(r)$, with $r \in R_i$ have
been examined.

Actually, the prefix-free property cannot be tested without knowing the
strings associated to the reads in $R_i$.

 However, we will use the length of the extension as a criteria to test
the property ... as detailed in the procedure
\emph{Checkifirreducible}....


Our approach is based on the idea that each edge $(r, r_e)$ in a String graph is
associated to a \emph{terminal extension pair} whose definition follows.
We will also detail how we can compute efficiently all terminal extension pairs
using the idea of bidirectional FM-index~\cite{Lam2009}.

\begin{definition}\label{def:extension-pair}
Let $S$ and $E$ be two strings and let $L$ be equal to $|S|+|E|$.
Then let $q_{1}'$ be the $rev(E)rev(S)\$$-interval of $B'$ and let  $q_{2}'$ be the $\$rev(S)$-interval of $B'$.
If both $q_{1}'$ and  $q_{2}'$ are nonempty, then the pair  $(q_{1}', q_{2}')$ is called
an \emph{extension pair} of dimension $L$.
\notaestesa{GDV}{ qui invece dimension è analogo alla length di un $Q$-interval}
% is a pair $(q_{1}', q_{2}')$ of
% intervals on $B'$, such that $q_{2}''$ is a $rev(E)rev(S)\$$-interval,
% $q_{2}'$ is a $\$rev(S)$-interval, and $|rev(E)rev(S)| = L$.
Moreover $(q_{1}', q_{2}')$ is a \emph{terminal} extension pair
if and only if $q_{1}'$ has a nonempty \$-backward extension on $B'$.
\end{definition}

The interval $q_{1}'$ corresponds to the reads with prefix $SE$, while $q_{2}'$
corresponds to the reads with suffix $S$.
The length of the string $E$ is called the \emph{extension} of the
pair, while the string $S$ is called the \emph{seed}.
In other words, the extension pair corresponds to the fact that the reads related to $q_{2}'$ are extended by the reads
of $q_{1}'$.
In a terminal extension pair, the concatenation of the seed and the extension is
equal to some $r_{e}$.




The correctness of our approach relies on the fact that all possible
terminal extension pairs will be examined during the iterations and thus
the arc-set of the final String graph over $R$ will be computed.
More precisely, we will construct all extension pairs with seed at least $\tau$ long, since only such extension pairs can result in arcs.
Morever, the extension pairs are computed for increasing dimension.


The String-graph is memorized in RAM as a list of arcs....
\notaestesa{Paola}{qua va detto come è memorizzato il grafo e si accede
agli archi}


The formulation of a String Graph used in~\cite{Simpson2010} is the same as
originally proposed in~\cite{Myers2005}, that is the graph is built by (1)
constructing a graph whose vertices are the reads and each arc connects two overlapping reads, and (2)
removing transitive edges.
Since the bottleneck of the construction of the String Graph is to compute and store all overlapping reads,
in~\cite{Simpson2010} the authors propose a single step procedure to build a
String Graph, computing only \emph{irreducible} edges, \ie non
transitive edges of the overlap graph.
Under the assumption that $R$ does not contain two reads where one is a substring of the other,
an edge $(r_{1}, r_e)$ is irreducible if there does not exists a read $r_{2}$
such that
the extension of $r_{1}$ with $r_2$ is a prefix of
the extension of $r_{1}$ with $r_e$.
% Moreover, if all reads in $R$ are extracted from a single genome and do not contain errors,
% the procedure proposed in~\cite{Simpson2010}, is guaranteed to compute exactly the irreducible arcs.
% This procedure computes, for any given read $r$, the shortest nonempty extension of $r$ with any read $r_{e}$
% where ties are broken by taking the smallest read $r_{e}$ \wrt the lexicographic order.
% All such pairs $(r, r_{e})$ are the arcs of the String Graph.\notaestesa{GDV}{ Rivedere questo paragrafo e amalgamarlo con la parte precedente}





%Given a collection $R$ of reads and a read $r \in R$,  let  $E(r)$ be
%the set of all strings that are extensions of read $r$ in $R$.
%Observe that given set $E(R_r)$,  pair of strings   in  $E(R_r)$  are
%either  one prefix of the other or they
% The  \emph{arc-set}  $A_r$ of  read $r$ in the collection $R$ consists
% of  all  reads  in $R$ having an  extension   with $r$ that is
% prefix-free in $E(r)$.

%\begin{definition}
%Given a set $R$ of reads, the \emph{String Graph SG}  over $R$ is the
%graph $(R, A)$, where the edge set $A$ is given by all pairs $(r, u) $,
%for $u \in A_r$, for each $r \in R$.
%\end{definition}


To compute the extension pairs we need to find, among all Q-intervals, those corresponding to prefixes of a read.
This fact is formalized with the notion of P-interval.


\begin{definition}
A \emph{P-interval} is a $rev(Q)$-interval $[b',e')$ on $B'$ containing
a $rev(Q)\$$-interval of width $\alpha>0$.
Moreover, $\alpha$ is called the \emph{dimension}\notaestesa{GDV}{ perchè dimension invece di width?}
of the P-interval.
\end{definition}

A \emph{P-interval} $[b',e')$ of dimension $n$ represents the $(e'-b')$
reads sharing $rev(Q)$, and $n$ among these reads share $Q$? as a
prefix.


The main step of our external memory algorithm consists of building efficiently
the $Q$-intervals on $B$ and the $rev(Q)$-intervals on
$B'$ by iteratively increasing the length $l$ of $Q$.
The first iteration considers $Q$-intervals where $l=\tau$.
Each iteration increases $l$ by one, until $l$ is equal to the maximum length
of a read in $R$. Moreover,
% is reached and each iteration uses the main functions
% of the FM-index, $Occ$ and $C$, detailed before.
we analyze the intervals to
maintain (for each read $r$), a set $I_{r}$ of reads inducing maximum overlaps with $r$.
We can show that the reads in the set $I_{r}$ are irreducible.
\begin{comment}
The computation of $Q$-intervals on $B$ and the $rev(Q)$-intervals on
$B'$ is used to compute for each read $r$ arc set $A_r$ whenever they
are produced by the processing of all $Q$-intervals and
$rev(Q)$-intervals.
In fact, by means of $Q$-intervals and $rev(Q)$-intervals, at each
iteration we can compute a set of reads inducing maximum overlaps with a
given read $r$ and which is $R$-irreducible, whenever the iteration
allows to infer $A_r$.
\end{comment}
The novel idea is that of maintaining the information of maximum
overlaps between all pair of reads as well as of the extension sets;
in fact
both information can be used to produce the list of arcs.\notaestesa{GDV}{ Io
  toglierei da Moreover in poi}



Our algorithm builds upon two methods presented in~\cite{Bauer2011,Cox2012}.
The first method computes the BWT of a collection of strings using $|\Sigma|$
external files, where each file contains the portion of BWT related to the suffixes
starting with the symbol $\sigma$.
The second method allows to construct (in external files) BWT intervals
of increasing length.
\notaestesa{Paola}{va detto qualcosa di più almeno nell'introduzione
  sull'uso della memoria interna}.

\begin{comment}
In particular, the procedure \emph{processInterval} given
in~\cite{Cox2012} is used in our algorithm to produce the sorted list
(lexicographical order) of the intervals of a given length $l$, from the
sorted list of the intervals of length $l-1$ (intervals of length $1$
can be easily obtained by means of the FM-index function $C$).
\notaestesa{Raffa}{Togliere lo pseudocodice della procedura processInterval: \'e della Rosone e non nostro.}.
\notaestesa{GDV}{ Concordo di togliere lo pseudocodice.
Bisogna dire però cosa calcola la procedura}

We extend the procedure \emph{processInterval} to
\emph{processLinkedInterval}, where we produce not only the $Q$-intervals on $B$, but also the linked
$rev(Q)$-intervals on $B'$.
\end{comment}



Let us now describe the main procedure \emph{buildGraph$(R, \tau)$} that
builds the String Graph.
The algorithm builds iteratively three lists,
that are actually implemented by files that are read sequentially.
At each iteration $j$ (starting from $j=0$), the following lists are computed,
\begin{itemize}
\item $\mathcal{Q}_j$, containing the nonempty $Q$-intervals $[b, e)$ on $B$ with length $(j+\tau)$,
each one with its linked
  $rev(Q)$-interval $[b', e')$ on $B'$.
\item $\mathcal{T}$, containing the nonempty $rev(Q)$-intervals $[b', e')$ of
  length $(j+\tau)$ which are $P$-intervals, each one with its dimension
  $n$.
\item $\mathcal{E}_j$, containing the extension pairs $(q_{1}', q_{2}')$ of
  dimension $(j+\tau)$, each one with its extension $e$ $> 0$
\end{itemize}

At each iteration, we analyze those list to find new possible arcs of the string graph and to determine whether they are reducible.
Clearly,  the lists obtained with the  $j$-th iteration will be used in the subsequent  $(j+1)$-th iteration.


\paragraph{Iteration $j = 0$.}

At the first iteration $j=0$, the list $\mathcal{Q}_0$ contains the
common substrings of length $\tau$, while  $\mathcal{T}_0$ and $\mathcal{E}_0$ are empty.

\paragraph{Iteration $j > 0$.}
During the $j$-th iteration, we compute
(i) the list $\mathcal{Q}_{j}$ of the
intervals of length $(j+\tau)$  -- by backward extending each $Q$-interval $[b, e)$ on $B$ in $\mathcal{Q}_{j-1}$ (and the
linked $rev(Q)$-interval on $B'$) in $\mathcal{Q}_j$  --
(ii) the list $\mathcal{T}_{j}$ of the
\emph{P-intervals} of length $(j+\tau-1)$ -- by backward extending each interval
in $\mathcal{T}_{j-1}$   -- , and
(iii) the list $\mathcal{E}_j$ of
extension pairs of dimension $j$ -- by noticing that for each extension pair
$(q_{1}',q_{2}')\in \mathcal{E}_j$ (iii a) $q_{1}'$ is a $\sigma$ backward extension
of $q_{2}'$ -- the extension consists of a single character -- or  (iii b)
$q_{1}'$ is a $\sigma$ backward extension
of $q'$ where $(q',q_{2}')\in \mathcal{E}_{j-1}$ -- the extension is one
character longer than in iteration $j-1$.
% --
% or (iii c)
% $q_{2}'$ is a $\sigma$ backward extension
% of $q'$ where $(q_{1}',q')\in \mathcal{E}_{j}$ -- we move the first character of
% the extension to the end of the seed.


% The list $\mathcal{Q}_{j}$ will be used during the next iteration
% $(j+1)$, and represents common strings of length increased by $1$.

Since the core of our approach is the extension of $Q$-intervals, we will
describe the steps that are necessary to achieve that.
The problem has been tackled in the literature by
the procedure \emph{processInterval}~\cite{Cox2012} which is also used in our algorithm to produce the sorted list
(lexicographical order) of the intervals of a given length $j+1$, from the
sorted list of the intervals of length $j$. Notice that the intervals of length $1$
can be easily obtained from the  function $C(\sigma, R$) which is part of the FM-index.


The procedure \emph{processInterval} takes in input a $Q$-interval $[b,e)$ of
length $l$, the BWT $B$, a vector $\Pi$ of $|\Sigma|$ counters, an array $F$ of
$|\Sigma|$ external files, and writes all the backward $\sigma_i$-extensions of
$[b,e)$ into the files $F$.\notaestesa{GDV}{ perchè non ho il file $F(\$)$?}
More precisely, the $\sigma_i Q$-interval is appended to the file $F[i]$.
This procedure computes the FM-index function $Occ(\sigma_i, i, R)$ using two
vectors: the (global) input vector $\Pi$ and the local vector $\pi$.
The first one stores in $\Pi[i]$ the number of occurrences of  the symbol
$\sigma_i$ in the BWT prefix $B[1,b-1]$, \notaestesa{GDV}{ ovvero
  $Occ(\sigma_{i}, b)$} while $\pi[i]$ stores the number of occurrences of $\sigma_i$ in the interval $[b,e)$. At the beginning, the vector $\Pi$ contains $|\Sigma|$ counters, each one set to $0$, and the $|\Sigma|$ files $F$ are empty.
After calling this procedure on each one of the $Q$-intervals of length $l$, supposed to be available in lexicographic order (thus, two consecutive intervals are disjoint), then  at the end each file $F[i]$ will contain the sorted list of the intervals of length $(l+1)$, starting with symbol $\sigma_i$. Considering files $F$ in the order $F[1], F[2], \ldots ,F[|\Sigma|]$, we obtain the sorted list of the intervals of length $(l+1)$. After each procedure call, the vector $\Pi$ is updated, to be passed to the next procedure call.\\
By assuming that input $Q$-intervals of length $l$ are available in lexicographical order, this procedure is able to update $\Pi$ and $\pi$ by reading the symbols of $B$ consecutively.

We have extended \emph{processInterval} to manage also the linked intervals on
$B'$; see procedure \emph{processLinkedInterval}.
Our procedure takes in input $Q$-interval $[b,e)$ and its linked
$rev(Q)$-interval $[b',e')$, and outputs (appending to the external files $F$)
the extended $\sigma_i Q$-intervals, each  with the linked $rev(Q)
\sigma_i$-interval on $B'$
Our procedure writes to $F$ the start and the end of the output intervals on the
complete BWT (see line 5), differently from~\cite{Cox2012} where they write, for each output $Q$-interval, its start \wrt to the BWT segment related to the starting symbol of $Q$, and its width.
At each iteration $i$ over the alphabet symbols the forward $\sigma_i$-extension
of the $rev(Q)$-interval $[b',e')$ is performed by counting
the number of symbols in $B[b,e)$ which are lexicographically smaller than
$\sigma_i$ just as in~\cite{Simpson2010}.
We recall that the correctness of \emph{processLinkedInterval} is based on the
fact that all $Q$-intervals are processed (and extended) in lexicographic order.

% \notaestesa{Raffa}{Qui invece va la descrizione della nuova procedura \emph{processSingleInterval}, sempre se la teniamo... che determina la lista di tutti gli intervalli estesi di un $Q'$-interval su $B'$ - vedi modifica 6}.
% Notice that the files $F(\sigma)$ must be read according to the lexicographic order.







\begin{comment}
More precisely, the steps .... in algorithm \emph{processLinkedInterval}
directly provides the values of the new $\sigma Q$-interval and such
value is appended at the end of the new updated list (or file), in order
to maintain the lexicographic ordering.
In fact, the sorted property of the file, allows to update the files
while reading the files themselves, thus minimizing the operations on the
file.
\notaestesa{Paola}{nota bene il passo dal 3 al 9 non si capisce come sia
implementato in termini di memoria esterna ed interna - io sarei per
descrivere la procedura processLinkedInterval- dettagliandola rispetto
ai linked intervals, che però vanno definiti prima, in termini
costruttivi}.


Intervals $[b,e)$ in $\mathcal{Q}_j$ represent common strings $Q$ of
length $(j+\tau)$.
Their link to the $rev(Q)$-interval $[b',e')$ on $B'$ is easily
maintained (during the backward extension of the intervals of length
$(j+\tau-1)$ to produce the intervals in $Q_j$) by Prop.~\ref{proposition:linked-intervals}.
This list is partioned into $|\Sigma|$ files according to the starting
symbol of $Q$, and maintained sorted by ascending value of the start
$b$.
\end{comment}


The list $\mathcal{T}$ is actually stored as a file, and it is computed by
taking into account that a
\emph{P-interval} $[b', e')$ with dimension $k$ is linked to a
$Q$-interval $[b, e)$ with exactly $k$ backward $\$$-extensions.
Notice that the only operations allowed on that file are appending an item to
the end and popping (\ie reading from the head and deleting) an item.
Moreover we need to maintain the list $\mathcal{T}$ sorted by ascending value of the starting
value $b'$ (\ie lexicographical order of $rev(Q)$).
In fact, let us recall that a \emph{P-interval} $[b', e')$ correspond to
the ordered list of reads having substring $rev(Q)$ on $B'$.

Each element of the list $\mathcal{T}$ is made of a  \emph{P-interval} $[b',e')$
and the width $n$ of the \$ forward extension of $[b',e')$ in $B'$.
Each P-interval is backward
extended to compute the extension pairs $(q_{1}', q_{2}')$ with
dimension $(j+\tau+1)$ and $E$ consisting of one character.
More precisely, given an element  $<[b',e'), n>$ of $\mathcal{T}$,
we pose $q_{2}'$ equal to the $\$$ forward extension of  $[b',e')$ and
for each $q_{1}'\in X(b',b'+n)$ we add the extension pair  $(q_{1}',q_{2}')$ to
the list $\mathcal{E}_{j+1}$.\notaestesa{GDV}{ quando viene creata la lista
  $\mathcal{E}_{1}$? Nell'iterazione 0?}
Notice that the interval $[b', b'+n)$ (under our assumption) cannot have
extensions with symbol $\$$: in fact, no read in $R$ can have $Q$ both
as a prefix and a suffix.\notaestesa{GDV}{ non mi convince la frase sull'assunzione}
Notice that, just as for the lists $\mathcal{Q}_j$ and $\mathcal{T}$, also the
lists  $\mathcal{E}_j$ are stored as a file.


Moreover we try to extend each extension pair of dimension $j+\tau$ into some
extension pairs of dimension $j+\tau+1$.
More precisely, for each extension pair $(q_{1}', q_{2}')$ in  $\mathcal{E}_j$ and
for each $q_{1}'\in X(b',b'+n)$ we add the extension pair  $(q_{1}',q_{2}')$ to
the list $\mathcal{E}_{j+1}$.\notaestesa{GDV}{ dove viene memorizzato $n$?}
% At each iteration $j$, the interval $q_{1}'$ of a pair $(q_{1}', q_{2}')$ with
% extension $e$ in $\mathcal{E}_j$ is backward extended on $B'$, where
% $q_{1}'$ is given.
% Observe that each $\sigma$  backward extension corresponds to a  forward
% extend by $\sigma$ on $B$ the  \$ $Q$-intervals, \ie computing the
% interval of reads having $Q \sigma$ has prefix (see figure \ref{}).


If $q_{1}'$ has a (unique under our assumption) extension with symbol $\$$
into the interval $[b'_r, b'_r+1)$, then the read represented by that
interval is added to the arc-set of each read represented by the
interval $q_{2}'$ (and no extension pair is added to $\mathcal{E}_{j+1}$).
\notaestesa{Paola}{qua occorre dire il perchè} In fact, it means that ....

Such arc-sets are checked, in order to guarantee their
\emph{irreducibility}.
\notaestesa{Paola}{questa parte è da rivedere ... cosa si intende per
  irriducibilità?}
Notice that just $(j+\tau)$-long reads are added to arc-sets at the
$j$-th iteration.
Otherwise (if $q_{1}'$ has no extension with symbol $\$$), an extension
pair $(q_e, q_{2}')$ (of dimension $(j+\tau+1)$ and extension $e+1$) is
added to the list $\mathcal{E}_{j+1}$, for each $q_e \in X(q_{1}')$, where
$X(q_{1}')$ is the set of the intervals obtained by backward extending
$q_{1}'$ with each $\sigma \in \Sigma$.

At each iteration $j$, the list $\mathcal{E}_{j+1}$ receives extension
pairs both from $\mathcal{T}$ and $\mathcal{E}_{j}$.
Since, the length of the intervals $[b', b'+n)$ in $\mathcal{T}$ is
equal to the length of intervals $q_{1}'$ in $\mathcal{E}_{j}$, the
algorithm can extend the union of the two lists, and therefore keep
sorted also the list $\mathcal{E}_{j+1}$, by ascending value of the
start of the interval $q_{1}'$ on the BWT $B'$.




A $rev(Q)$-interval  $[b',e')$ in $\mathcal{T}$ represents common
strings $Q$ of length $(j+\tau)$ occurring $n$ times as a prefix in $R$.
Recall that the interval $[b',b'+n)$ represents the reads having $Q$ as
a prefix.


The seeds of the extension pairs in $\mathcal{E}_j$
%(partitioned in $|\Sigma|$ files according to the first symbol of ??)
have a length $< (j+\tau)$ and are the common substrings considered at
the previous iterations $< j$.
\notaestesa{Paola}{a me sembra che al passo $j$ la lunghezza sia $< =<
  (j+\tau)$- ricontrollare bene}


\section*{Pseudocode}

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

%\Input{$R$, a collection of reads,\\$\tau$, the minimum length of the overlap between two reads}
%\Output{the arc set $R_r$ of each $r \in R$}

\tcp{Get the collection of the reverse of the reads}
$R' \gets \{rev(r): r \in R\}$\;
$B \gets BWT(R)$\;
$B' \gets	BWT(R')$\;

$\mathcal{Q}_{0} \gets$ create the $|\Sigma|$ files of the $Q$-intervals of length $\tau$, each one with its linked $rev(Q)$-interval\;
$\mathcal{E}_0 \gets \emptyset$\;

\tcp{Initially each arc set is empty}
$R_r \gets \emptyset$ for each $r \in R$\;

$j \gets 0$\;

\While{$(\mathcal{Q}_j \cup \mathcal{E}_j) \ne \emptyset$}{
 $\mathcal{Q}_{j+1}\gets$ create $|\Sigma|$ empty files\;
$\mathcal{T}\gets$ create an empty file\;
  $extendQOnLeft(\mathcal{Q}_j, B, \mathcal{Q}_{j+1}, \mathcal{T})$\;
  sort $\mathcal{T}$\;
  $\mathcal{E}_{j+1} \gets extendQOnRight(\mathcal{T}, \mathcal{E}_j, B')$\;
  $j \gets j+1$\;
}
\Return{$R_r$ for each $r \in R$}\;

\caption{buildGraph($R$, $\tau$)}
\label{alg:build-graph}

\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{algorithm}
%\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
%
%\Input{$B$, the BWT of $R$,\\ $t$, the length of the returned BWT intervals}
%\Output{$I_t$, the sorted list of the BWT intervals of length $t$ and width $>1$}
%
%$k \gets 1$\;
%$I_k \gets$ empty list\;
%%Create $|\Sigma|$ files $I_k(\sigma)$, for each $\sigma \in \Sigma$\;
%\For{$i \gets 1$ \KwTo  $|\Sigma|$}{
%  $b \gets C_T(\sigma_i)$\;
%  $e \gets C_T(successor(\sigma_i)$\;
%  \If{$(e-b) > 1$}{
%    Append $\langle [b,e),[b,e), \sigma_i \rangle$ to $I_k(\sigma_i)$\;
%  }
%}
%
%\For{$k \gets 2$ \KwTo  $t$}{
%  %Open $|\Sigma|$ files $I_k(\sigma)$, for each $\sigma \in \Sigma$\;
%  $I_k \gets$ empty list\;
%  Initialize vector $\Pi \gets [0, 0, . . . , 0]$ of $|\Sigma|$ integers\;
%  \For{$i \gets 1$ \KwTo  $|\Sigma|$}{
%     \ForEach{$\langle [b,e),[b',e'), \sigma^* \rangle \in I_{k-1}(\sigma_i)$}{
%        $L \gets processLinkedInterval([b,e),[b',e'),B,\Pi)$\;
%        \For{$p \gets 1$ \KwTo  $|\Sigma|$}{
%	  $\langle [b_p,e_p),[b'_p,e'_p)\rangle \gets L[p]$\;
%	  \If{($e_p-b_p)>1$}{
%	     Append $\langle [b_p,e_p),[b'_p,e'_p), \sigma^* \rangle$ to $I_k(\sigma_p)$\;
%	   }
%         }
%    }
%  }
%  Delete $I_{k-1}$\;
%}
%
%\Return{$I_t$}\;
%
%\caption{getQIntervals($B$, $t$)}
%\label{alg:get-intervals}
%\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

%\Input{$F$, the $|\Sigma|$ external files containing the $Q$-intervals of length $l$ each one with its linked interval on $B'$\\$B$, the BWT of the collection $R$,\\
%$F_e$, an array of $|\Sigma|$ empty files,\\$\mathcal{T}$,  an empty file}

Initialize a vector $\Pi \gets [0, 0, . . . , 0]$ of $|\Sigma|$ counters\;

 \For{$i \gets 1$ \KwTo  $|\Sigma|$}{
      \ForEach{$\langle [b,e),[b',e')\rangle \in F(i)$}{
	$processLinkedInterval([b, e),[b', e'),B,\Pi, F_e)$\;
\tcp{check if $[b',e')$ is a $P$-interval}
	\If{$[b,e)$ has width $>1$ and $n >0$ $\$$-extensions}{
            write $\langle [b', e'), n\rangle$ to file $\mathcal{T}$\;
	}
     }
}

\caption{extendQOnLeft($F$, $B$, $F_e$, $\mathcal{T}$)}
\label{alg:extend-left}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{$\mathcal{T}$, the sorted list of the $P$-intervals of a given length $l$,\\$\mathcal{E}$, the sorted list of the extension pairs of dimension $l$,\\$B'$, the BWT of the reversed set $R'$}
\Output{$\mathcal{E}_{e}$, the sorted list of the extension pairs of dimension $(l+1)$}

$\mathcal{E}_{e} \gets \emptyset$\;

Initialize vector $\Pi \gets [0, 0, \ldots , 0]$ of $|\Sigma|$ integers\;

    \While{$(\mathcal{T} \cup \mathcal{E}) \neq \emptyset$} {
             $\langle [b', e'), n \rangle \gets pop((\mathcal{T})$\;
             $\langle [b'_p, e'_p), [b'_s,e'_s), e \rangle \gets pop(\mathcal{E})$\;
		\If{$(b' < b'_p)$} {
			$push(\mathcal{E}, \langle  [b'_p, e'_p), [b'_s,e'_s), e \rangle)$\;
			$L \gets processInterval([b', e'), B', \Pi)$\;
                           $[b'_{s}, e'_{s}) \gets L[1]$\;
			\If{$(e'_{s} - b'_{s}) > 0$} {
                                   $L \gets processInterval([b', b'+n), B', \Pi)$\;

				\For{$i \gets 2$ \KwTo $|\Sigma|$} {
                                             append $\langle L[i], [b'_{s}, e'_{s})\rangle$ to $\mathcal{E}_e(\sigma_i)$ if $L[i]$ is not null\;
				}
			}
		}
		\Else {
			$push(\mathcal{T}, \langle  [b', e'), n \rangle)$\;
                           $L \gets processInterval([b'_p, e'_p), B', \Pi)$\;
                           $[b'_{p\$}, e'_{p\$}) \gets L[1]$\;
			\If{$(e'_{p\$} - b'_{p\$}) > 0$} {

			   \ForEach{$r \in R(b'_s,e'_s)$}{
          			$r_e \gets R(b'_{p\$}, e'_{p\$})$\;
				$checkIfIrreducible(r, r_e, e)$\;
                             }
			}
			\Else {
				\For{$i \gets 1$ \KwTo $|\Sigma|$} {
					$[b_a, e_a) \gets updateBwd([b, e), \sigma_k, \Pi, \pi, B')$\;
					\If{$(b_a < e_a)$} {
						Append($\langle L[i], [b'_s, e'_s), e+1 \rangle$) to $\mathcal{E}_e(\sigma_i)$ if $L[i]$ is not null\;
					}
				}
			}
		}
	}

\Return{$\mathcal{E}_{e}$}\;

\caption{extendOneStepRight($\mathcal{T}$, $\mathcal{E}$, $B'$)}
\label{alg:extend-right}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

%\Input{$[b,e)$, a $Q$-interval on $B$,\\$[b',e')$, the linked $rev(Q)$-interval on $B'$,\\$B$, the BWT of the collection $R$,\\$\Pi$, the vector of $|\Sigma|$ counters,\\
%$F$, an array of $|\Sigma|$ empty files}

%Update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B[0,b-1]$\;
\tcp{$\Pi[i]$ is the number of $\sigma_i$ in $B[0,b-1]$}
Create a vector $\pi$ of $|\Sigma|$ counters \st $\pi[i]$ is the number of $\sigma_i$ in $B[b,e)$\;
$\pi sum \gets 0$ \tcp{$\pi sum$ is always the number of symbols $< \sigma_i$ in $B[b,e)$}
\ForEach{$i \gets 1$ \KwTo  $|\Sigma|$}{
\tcp{compute the start of the $\sigma_i Q$-interval}
   $b_e \gets |R|+C(\sigma_i, R)+ \Pi[i]$\;
\tcp{compute the end of the $\sigma_i Q$-interval}
   $e_e \gets b_e + \pi[i]$\;
   $b'_e \gets b'+ \pi sum$\;
   $e'_e  \gets b'_e + \pi[i]$\;
   write $\langle [b_e, e_e), [b'_e, e'_e)\rangle$ to file $F(i)$\;
\tcp{update $\pi sum$ to the number of symbols $< \sigma_{i+1}$ in $B[b,e)$}
   $\pi sum \gets \pi sum + \pi[i]$\;
}

%\tcp{update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B[0,e-1]$}
$\Pi \gets \Pi+\pi$\;

\caption{processLinkedInterval($[b,e)$,$[b',e')$, $B$, $\Pi$, $F$)}
\label{alg:process-linked-interval}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

\Input{$[b,e)$, a $Q$-interval on a BWT $B$,\\$B$, the BWT of a collection of strings,\\$\Pi$, a vector of $|\Sigma|$ integers}
\Output{$L$, the list of the extended intervals on $B$}

Update $\Pi$ such that $\Pi[i]$ is the number of $\sigma_i$ in $B[0,b)$\;
Create a vector $\pi$ of $|\Sigma|$ integers \st $\pi[i]$ is the number of $\sigma_i$ in $B[b,e)$\;

$L \gets \emptyset$\;
\For{$i \gets 1$ \KwTo  $|\Sigma|$}{
   $b_i \gets C_T(\sigma_i)+ \Pi[i]$\;
   $e_i \gets b_i + \pi[i]$\;

   Add $[b_i, e_i)$ to L\;
}

\tcp{Update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B[0,e)$}
$\Pi \gets \Pi+\pi$\;

\Return{$L$}\;

\caption{processInterval($[b,e)$, $B$, $\Pi$)}
\label{alg:process-interval}
\end{algorithm}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{$r_1$, a read,\\$r_2$, a read extending $r_1$,\\$e$, the extension length of $r_2$ \wrt $r_1$}
\Output{}

$adjList \gets getAdjList(r_1)$\;
\If{$adjList = \emptyset$} {
	append($r_2, e$) to $adjList$\;
}
\Else {
	$(r_a, e_a) \gets adjList[0]$\;
	\If{$e < e_a$} {
                 $adjList \gets \emptyset$\;
		Append($r_2, e$) to $adjList$\;
	}
}

\caption{checkIfIrreducible($r_1, r_2, e$)}
\end{algorithm}


\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

%\Input{$[b',e')$, a $Q'$-interval on $B'$,\\$B'$, the BWT of the collection $R'$,\\$\Pi$, a vector of $|\Sigma|$ counters}

%\Output{$X$, the set of all the backward $\sigma_i$-extensions of $[b',e')$}

Update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B'[0,b'-1]$\;
Create a vector $\pi$ of $|\Sigma|$ counters \st $\pi[i]$ is the number of $\sigma_i$ in $B'[b',e')$\;

$X \gets \emptyset$\;

\ForEach{$i \gets 1$ \KwTo  $|\Sigma|$}{
\tcp{compute the start of the $\sigma_i Q'$-interval}
   $b'_e \gets |R'|+C'(\sigma_i, R')+ \Pi[i]$\;
\tcp{compute the end of the $\sigma_i Q'$-interval}
   $e'_e \gets b'_e + \pi[i]$\;
   add $[b'_e, e'_e)$ to $X$\;
}

\tcp{update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B'[0,e'-1]$}
$\Pi \gets \Pi+\pi$\;

\Return{X}\;

\caption{processSingleInterval($[b',e')$, $B'$, $\Pi$)}
\label{alg:process-linked-interval}
\end{algorithm}

\section{On the complexity}


------ricordarsi la questione del fatto che usando un  dollaro unico per tutti i reads si perde l'ordiamento  dei reads  -----



Given a set of reads $R$ of cardinality $n$, let $l$ be the maximal
length of a read in $R$.

% and let us recall that $n$ is the total number of reads ($R$)

The time complexity for building the BWT of the collection $R$ of reads
is the one reported in the paper ((Lightweight BWT Construction for Very
Large String Collections)\cite{}).
More precisely, using BCR we can build the data structure in
$O(l\times sort(n))$ whereas using BCRext the time complexity
is $O(ln)$.

Observe that the buildgraph procedure consists of iterating at most $l$
times the procedures ExtendQonLeft and ExtendQonRight.
In fact, those two procedures
%the procedures ExtendQonLeft and ExtendQonRight
apply the backward extension to every $Q$-interval in $\mathcal{Q}_j$ at
most $l$ times, since there can't be any interval related to a pattern
$Q$ such that $|Q| > l$. % $Q$-interval has length at least $\tau$.

On the other hand the procedures ExtendQonLeft and ExtendQonRight aim to
build all the possible $Q$-intervals linked to the maximal overlaps
between the reads (the irreducible edges of the SGR graph) by means of
an incremental approach that rely on the computation of the
$Q$-intervals during the previous steps.

Thus, the time complexity of these procedures may be measured by
considering the total number of possible $Q$-intervals that we have to
compute for every length of $Q$ (more precisely for $|Q| \in \{1 \dots
l\}$).
% the fact that after the total number of iterations they have extended
% at most all possible $Q$-intervals in the data set $R$ for $|Q| \in
% \{1 \dots l\}$.

Then the total  complexity of ExtendQonLeft and ExtendQonRight is at
most $O(N_Q)$, where $N_Q$ is the total number of
$Q$-intervals (i.e. distinct substrings of $R$).

An estimate of $N_Q$ can be given as $O(l \times n)$ (let us recall that
the number of distinct strings in a word on length $x$ is  at most $x$
((Trovare articolo e citare)\cite{})).

Note that during the iteration step the buildgraph procedure has also to
sort $\mathcal{T}$.
Recall that, at a given iteration $i$, $\mathcal{T}$ is the set of
$Q$-intervals such that $Q$ is prefix for at least one read and $|Q| = i
+ \tau$; it's fairly clear that $|\mathcal{T}| \leq n$.
This procedure has a total time complexity $O(l \times
sort(n))$.

Hence the time complexity for building the string graph is
$O(l \times (n + sort(n)))$.
% of BWT in external memory and thus an estimate of the time over real
% data can be ....



\section{Conclusion and future work}
------
The above notion of String Graph applies to assembling RNA-seq data into
splicing graph~\cite{Beretta2013}.
When assembling RNA-seq data with an overlap graph, the final output
graph is not a line path, since the graph should represent the
alternative transcripts derived by the alternative splicing on the gene
structure.
In fact, RNA-seq data are classified into \emph{spliced} and
\emph{unspliced} reads.
Unspliced reads are reads that cover regions that are either coding or
not coding ones, i.e. they are absent or present in a transcript
sequence.
On the contrary a spliced read $r$ contains of at least two consecutive
substrings $r_i $, $r_{i+1}$ such that there exists at least two
transcripts where $r_i$ is present in a transcript sequence together
with $r_{i+1}$ while $r_i$ is present and $r_{i+1}$ is absent in the
transcript sequence.

In order to include this case we give a more general notion of
irreducible edges of an overlap graph.
Under the assumption that a read is not included in another one, the
transitive reduction of an overlap graph, by which we get a string graph
from an overlap graph, corresponds to require that the set of reads that
extends a read $r$ is irreducible.
This definition includes also the case of splicing graphs...

\bibliographystyle{splncs03}
\bibliography{biblioBWTpaper}


\end{document}

%  LocalWords:  transcriptomic novo NGS Bruijn BWT iff unspliced
