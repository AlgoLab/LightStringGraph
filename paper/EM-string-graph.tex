\documentclass[runningheads,envcountsame,a4paper]{llncs}
\pdfpagesattr{/CropBox [92 112 523 778]}

\usepackage[utf8]{inputenc}
\usepackage{microtype}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage[algoruled,linesnumbered,noend]{algorithm2e}
\usepackage{ifdraft}
\usepackage{enumitem}
\usepackage{cite}
\usepackage{multirow}
\usepackage{url}
\usepackage{xspace}
\usepackage{graphicx}

\newcommand{\coll}[1]{\url{#1}}

% REMOVE BEFORE SUBMISSION - begin part
\usepackage{verbatim}
\newcommand{\nota}[1]{%
  {\sffamily\bfseries #1}%
  \marginpar{\framebox{\Large *}}%
}
\newcommand{\notaestesa}[2]{%
  {\sffamily {\bfseries #1}{\footnotesize #2}}%
  \marginpar{\framebox{\Large *}}%
}

% \usepackage{tikz}
% \usetikzlibrary{shapes,arrows}
% \usetikzlibrary{snakes}
% \usetikzlibrary{positioning,patterns}


\newcommand{\mathfrc}[1]{\text{\fontfamily{frc}\selectfont#1}}

\usepackage{booktabs}
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\newcommand{\lmidrule}{\midrule[.4\heavyrulewidth]}
\usepackage{tabularx}
\newcolumntype{T}[1]{>{\tsize} #1}
\newcolumntype{W}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\usepackage{array}


\newcommand{\inputdata}[1]{\noindent \emph{Input: }#1\\*}
\newcommand{\outputdata}[1]{\noindent \emph{Output: }#1\\}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\ie}{\textit{i.e.},\xspace}
\newcommand{\st}{s.t.\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\renewcommand{\l}{\ensuremath{\ell}}
\renewcommand{\emptyset}{\ensuremath{\varnothing}}


\begin{document}

\title{Assembling of  string graphs by a lightweight BWT}

\author{%
  Paola Bonizzoni \and
  Gianluca Della Vedova \and
  Yuri Pirola \and
  Marco Previtali \and
  Raffaella Rizzi
}
\authorrunning{Bonizzoni \etal}

% \institute{DISCo,
%   Univ. Milano-Bicocca,
%   Milan, Italy\\ \email{\{beretta,bonizzoni,rizzi\}@disco.unimib.it}
% \and Dip. Statistica, Univ. Milano-Bicocca,
%   Milan, Italy\\ \email{gianluca.dellavedova@unimib.it}
% }

\maketitle

\begin{abstract}


\end{abstract}

\section{Introduction}
De novo sequence  assembly is a difficult problem  and is a necessary step  in analyzing data from next generation sequencing technologies (NGS).
NGS  produce from a  (genomic  or transcriptomic)  sequence a    huge amounts of short sequences, called reads. Usually reads are  compared to produce a  graph representation from which derive a path  representing the original sequenced sequence. Such a graph representation may be derived by overlap-based methods or building  De Brujin graphs \cite{Zerbino2008, Simpson2009, Peng2010}.
Overlap-based methods are based on computing pairwise overlaps among reads  and then representing reads as vertices and edges connect overlapping reads, where each edge $(r,r')$ may be labeled by the  suffix of $r'$ that  excedes the overlap between the two reads.  However, they require a comparison among reads that is quadratic in the total size of the input data.  These method are of particular interest in genome assembly since it applies to mixed length reads of  coming from different  next generation sequencing technologies.

Recently \cite{Simpson2010, Simpson2012}  have proposed string graphs as an alternative approach to de novo  genome assembly based on De Brujin graphs. The main  formulation was proposed by Gene Myers \cite{Myers2005}.  The method builds a graph from reads that  is obtained by   building an overlap graphs and  then implementing transitive reduction to produce a string graph where only maximal  overlaps are considered. More precisely, given a path $r \rightarrow r_1 \rightarrow r_2$ in a overlap graph,  and given the \emph{transitive} edge  $r \rightarrow r_2$, Simpson and Durbin \cite{Simpson2010}  observe that  (under the assumption of forbidding the substring property)  the string associated to edge   $(r, r_1) $  is a prefix of  the string associated to the transitive edge $(r, r_2)$.
Based on this property,  Simpson and Durbin \cite{Simpson2010}  define a notion of \emph{irreducible} edge  and    show  how to construct a string graph by outputting  directly  irreducible edges (instead of building an overlap-graph)  significantly shrinking memory
requirements and reducing compute time to be linear in the total size of the input data.  The   reduction in time and space in the string graph assembly problem  \cite{Simpson2010}  is achieved by    making use of  an implementation  of the problem by BWT and the FM-index apparatus.
In their works, Simpson and Durbin pose the question of further reducing the space requirements in solving the string graph assembly by an external memory construction of the FM-index.
In the meantime, an investigation of external memory construction of the  BWT  has been started in \cite{Bauer2011} showing that it is possible to  arbitrarily reduce the use of RAM for building a BWT and for solving  typical applications of the BWT  \notaestesa{Aggiungere rif biblio}. \notaestesa{altri rif a BWT in memoria esterna sono Ferragina2012, Bauer2013}.
In this paper, based upon the work in \cite{Bauer2011}, we show how to construct the string graph from a BWT for a collection of reads  that is completely in external memory.

The construction of the String graph in \cite{Simpson2010} works in two steps. In the first one,  for each read $r$ in the collection $R$,  the position in the BWT  ($Q$-interval)  of reads  that share with $r$ an overlap  given by a string $Q$  are computed
in time linear in the size of  $r$.  In the second step,  $Q$-intervals are extended to discover  irreducible edges.
Both   steps strictly require to keep the  whole FM-index and BWT sequence for $R$ and  for the collection of reversed reads  in main memory since the $Q$-intervals and the relative extensions cover different positions of  the whole BWT. Moreover, the algorithm requires to recompute   $Q$-intervals  a number of times that is equal to the number of  different reads in $R$ share the string  $Q$
as a suffix.


In our approach, we keep the BWT for the collection $R$ of reads and its reverse version, $R'$ in secondary memory and we read them sequentially, and during this process we iteratively forward and backward extend each $Q$-interval computed at a previous iteration.
Each iteration may produce  irreducible edges  that we keep in RAM.
%terminal extension pairs and we keep in RAM the String Graph for the subset of reads in  $R$ for which at least a $q'$-interval is in a terminal extension pair computed so far.  More precisely, at a %given iteration $i$, given $\mathcal{E}_i$  the terminal extension pairs at step $i$, if $R_i$ is the subset of reads which at least a $q'$-interval is in  extension pair of
%$\mathcal{E}_i$, then the algorithm produces the String graph over $R_i$ since only extensions that are prefix-free for sets $E(r)$, with $r \in R_i$ have been examined.




--------- non so dove vada-----------------


A key observation in our work is the fact that due to the fact that a BWT consists of the symbols that precedes the lexicographic ordering of suffixes of the reads of a collection, it is possible to "walk" consecutively on the BWT  of the collection of reads and of the reversed version of the reads and then building a forward and backward extension of a $Q$-substring by symbols of the alphabet lexicographically ordered. All this can be done entirely using  files for each symbol of the alphabet and files for the BWT and its reversed version.

% and by using the RAM only to keep an indexed representation of the string graph


\begin{comment}
descrizione The FM-index .... [inserire citazione FM-index]

 With the advent of NGS data, the investigation of the BWT has moved towards its use in indexing huge collections of texts, represented by the reads of variable length.
 The notion  of Extended Borrows Wheeler has been proposed to deal with a collection of texts \cite{Bauer2011} and iits potentiality in  Bioinformatics  to index read data has been investigated in ....

While the BWT has been deeply used for the alignment of reads to a reference genome, for the first time the BWT has been explored as a tool for de novo assembly.

In \cite{Simpson2010} Durbin addresses the problem of having a more efficient space FM-index implementation of the string graph problem.

---results----

\end{comment}


\section{Preliminaries}
Let $\Sigma = \{\sigma_1, \cdots, \sigma_m\}$ be an ordered  finite alphabet.
Given a string $r = a_1 \cdots a_l$, by $r[i]$ we denote the $i$-symbol $a_i$  of $r$ and by $r[i,k]$, with $i \leq k$  we denote  the substring $a_i \cdots a_k$ of string $r$.
Then $|r|$ is the length of string $r$. The {\em reverse} of a string $r = a_1 \cdots a_l$, denoted as $rev(r)$,  consists of the string $r' = a_l \cdots a_1$ obtained by reading $r$ from right to left.

The  {\em suffix} in position $i$ of $r$, in short  $i$-suffix of $r$,  is the substring $r[i, l]$. The   suffix and {\em prefix} of length $k$ of string $r$ are the substrings
$r[l-k +1, l]$ and $r[1, k]$ respectively of string $r$.

Let $R = \{r_1, \cdots, r_n\}$ be a collection of $n$ strings over $\Sigma$, where each sequence $r_i$ is ended by  a sentinel  symbol \$ that is not in the alphabet $\Sigma$ and is lexographically lower than any other symbol in $\Sigma$.
Let $SA(R)$ be the {\em generalized suffix-array} for the set $R$ consisting of  the array of  pairs $(i_j, p_i)$ for each index $i \in \{1, \cdots, n \}$, where
$SA(R)[i]=  (i_j, p_i)$ if and only if  the $i_j$-suffix of string $r_{p_i}$ is the $i$-th lowest in the lexicographic ordering of all suffices of strings in $R$. The generalized suffix-array is an indexing data structure for a collection of strings (\cite{Shi1996}).

Then the BWT of the collection $R$ is defined as the sequence $B_R$ such that $B_R[i]=r_{j}[k -1]$ if  $k > 1$ and   $SA[i] = (k,j)$, otherwise $B_R[i]= $ \$.
Informally, $B_R[i]$ is the symbol that precedes the  $k$-suffix  of  string $r_j$ where such suffix is the $i$-th lowest in  the ordering  of the generalized suffix array $SA$.
Clearly, the size of the suffix array is the sum of the length of all suffices of  strings in the collection $R$, and thus $SA$ is of size $N = \sum_{i \leq n}|r_i|$.
The string $B_R$ is a permutation of all symbols in the collection $R$ of strings and auxiliary arrays  that provide the FM-index (\cite{Ferragina2000}) for a BWT  of a text can be extended to a BWT of the collection and are defined as usual: $C(\sigma, R)$ denotes the number of symbols in $R$ that are lexographically lower than symbol $\sigma$, while $Occ(\sigma, i, R)$ is the array that reports the number of occurrences in $B_R[1, i]$ of symbol $\sigma$, including counting the number of sentinel symbols \$.

%Now, the string $B[i,k]$ for indexes $1 \leq i \leq k \leq N$ reports the sequence of symbols that precedes the ordered suffices in the generalized  suffix array $SA[i,k]$.

The two arrays $C(\sigma, R)$ and $Occ(\sigma, i, R)$ are crucial in computing  the positions of all occurrences of a string $Q$  in a collection $R$ of
strings and have been used in the search algorithm given by Ferragina and Manzini \cite{Ferragina2000}.

Observe  that the string $B[i,k]$ for indexes $1 \leq i \leq k \leq N$ reports the sequence of symbols that precedes the ordered suffices in the generalized  suffix array $SA[i,k]$.





\subsection*{The \emph{String Graph}}


A string $s$ is \emph{prefix-free} in a collection $S$ of strings,  if  for any  other string $s'$  in $S$, $s'$ is not a prefix of $s$.
 Given two reads $r_1$ and $r_2$, we say that $r_1$ and $r_2$ {\em overlaps}    if the suffix of $r_1$ is equal to a prefix of $r_2$ or vice versa.  If $r_1$ has a suffix $\alpha$ that is also a prefix of $r_1$, then we say that $r_2$  \emph{extends} $r_1$  by $|r_2|- |\alpha|$- symbols and the suffix $\beta$ such that $r_2 = \alpha \beta$ is called \emph{extension} of  $r_2$ with $r$.

The formulation of a  String Graph  used in \cite{Simpson2010} is the one originally proposed in \cite{Myers2005} that is the graph built by first constructing a graph of
the pairwise overlaps between   reads and  by removing transitive edges. More precisely, in \cite{Simpson2010} they propose to build a string-graph from \emph{irreducible} edges that should correspond  to non transitive edges  of the overlap graph.  Under the assumption that  a read is not a substring of another read $R$, an edge $(r, r_e)$  is irreducible whenever the extension of $r_e$ with $R$ is not a prefix of any other extension of a read $r'$ with $r$.  Considering genomic reads, a further property of irreducible edges is proposed in \cite{Simpson2010} and implemented with the FM-index approach:  the read $r_e$ having shortest extension with $r$ and  which  is the first generated in lexicographic order produces the edge $(r,r_e)$ of the string graph.




%Given a collection $R$ of reads and a read $r \in R$,  let  $E(r)$ be the set of all strings that are extensions of read $r$ in $R$.
%Observe that given set $E(R_r)$,  pair of strings   in  $E(R_r)$  are either  one prefix of the other or they
% The  {\em arc-set}  $A_r$ of  read $r$ in the collection $R$ consists of  all  reads  in $R$ having an  extension   with $r$ that is  prefix-free in $E(r)$.

%\begin{definition}
%Given a set $R$ of reads, the \emph{String Graph SG}  over $R$ is the graph $(R, A)$, where the edge set $A$ is given by all pairs $(r, u) $, for $u \in A_r$, for each $r \in R$.
%\end{definition}


\subsection{Forward and backward extension of $Q$-intervals}

In the following let $B$ be the BWT for the collection $R$.  Moreover, let $B'$ be the BWT of the set $R'$ of the reversed reads, that is $R' = \cup_{r \in R}rev(r)$.


Then a  {\em  $Q$-interval} $[b,e)$ of $B$ is the  substring  $B[b, e -1]$ containing symbols  that precede the string $Q$ in all strings  in $R$, that is each suffix  with index in the interval $SA[b, e-1]$ has $Q$ has a prefix.  In this framework, the \emph{length} of a $Q$-interval is the length of the string $Q$, while the \emph{width} of a $Q$-interval $[b, e)$ is the difference $(e-b)$. A $Q$-interval on $B$ of width larger than $1$  represents a string $Q$ having more than one occurrence in $R$ (\ie common substring).

In the following, we denote with $R(q)=R(b,e)$ the reads containing the BWT symbols of the interval $q=[b,e)$.


\begin{definition}
A $Q$-interval $[b,e)$ on $B$ and a $Q'$-interval $[b',e')$ on $B'$ are \emph{linked} iff $Q=rev(Q')$.
\end{definition}

Two linked intervals must have the same width, and it holds $(e-b)=(e'-b')$.
When a common string $Q$ occurs $n>0$ times as a prefix in $R$, then the $Q$-interval $[b,e)$ contains $n$ symbols $\$$, and the $\$ Q$-interval represents the set of the $n$ reads where $Q$ occurs as a prefix. The linked $rev(Q)$-interval $[b',e')$ will contain a $rev(Q)\$$-interval $[b',b'+n)$. The $\$ Q$-interval is clearly linked to the $rev(Q)\$$-interval.

\begin{definition}
A \emph{P-interval} is a $rev(Q)$-interval $[b',e')$ on $B'$ containing a $rev(Q)\$$-interval of width $n>0$ ($n$ is called the \emph{dimension} of the \emph{P-interval}).
\end{definition}

A \emph{P-interval} $[b',e')$ of dimension $n$ represents the $(e'-b')$ reads sharing $rev(Q)$, and $n$ among these reads share $rev(Q)$ as a prefix.

%When a substring $Q$ occurs $m>0$ times as a suffix in $R$, then the $rev(Q)$-interval on $B'$ contains $m>0$ symbols $\$$, and the $\$ rev(Q)$-interval represents the set of the $m$ reads %where $Q$ occurs as a suffix.

%\begin{definition}
%A \emph{S-interval} is a $rev(Q)$-interval $[b',e')$ on $B'$ having $m>0$ backward extensions with symbol $\$$  ($m$ is called the \emph{dimension} of the \emph{S-interval}).
%\end{definition}

In the following, we call \emph{\$-interval} a BWT interval related to suffixes starting with $\$$, and denote with $X(q)$ the set of all the backward extensions of the interval $q$ with each one of the symbols $\sigma \in \Sigma$.


Our  procedure to find the arc-set $A_r$ for each read $r$   is based on the idea of  building all the possible $Q$-intervals that are overlaps of reads in $R$ and then iteratively extend
forward the $Q$-interval in those reads that have $Q$ as a prefix until the sentinel symbol \$ is found, i.e. the reads are terminated. The extension of such reads with $r$ are compared with the one
that has been computed till the iteration step in order to compute  the String graph over the set of  reads whose $Q$-intervals and forward extensions have been examined so far.

The following notion of \emph{extension pair} is crucial for implementing the above idea using FM-index in two directions (\cite{Lam2009}).


\begin{definition}
\label{extension-pair}
An \emph{extension pair} of dimension $L$ is a couple $(q'', q')$ of intervals on $B'$, such that $q''$ is a $rev(\beta)rev(S)\$$-interval, $q'$ is a $\$rev(S)$-interval,
and $|rev(\beta)rev(S)| = L$.
\end{definition}

The interval $q''$ represents reads sharing a prefix $S\beta$, and $q'$ represents reads sharing a suffix $S$. The length of the string $\beta$ is called the \emph{extension} of the pair, while the string $S$ is called the \emph{seed}. In other words, the reads related to $q'$ are extended by the reads related to $q''$, and all the extensions start with the string $\beta$.

An extension pair $(q'', q')$ is \emph{terminal} if and only if $q''$ is the \$-backward extension on $B'$ of an interval on $B'$.
\notaestesa{Paola}{rivedere anche in termini informali}


The main step of the algorithm is the computation in external memory of extension pairs and it requires   searching the FM-index in two directions, first backwards to determine the intervals of overlapping prefixes and then forwards to extend those prefixes and build the terminal extensions.

The construction of the String graph in \cite{Simpson2010} works in two steps. In the first one,  for each read $r$ in the collection $R$, all $Q$-intervals of reads overlapping  $r$ are computed
in time linear in the size of  $r$.  In the second step, each of this interval are forward extended in order to discover the first \$ extension of the $Q$-interval representing an irreducible edge.
Observe that the two steps strictly require to keep the  whole FM-index and BWT sequence for $R$ and $R'$  in main memory since the $Q$-intervals and the relative extensions cover different positions of  the whole BWT. Moreover, the algorithm requires to recompute   $Q$-intervals  a number of times that is equal to the number of  different reads in $R$ share the string  $Q$
as a suffix.


In our approach, we keep the BWT for the collection $R$ of reads and its reverse version, $R'$ in secondary memory and we read them sequentially, and during this process we iteratively forward and backward extend each $Q$-interval computed at a previous iteration.
Each iteration may produce terminal extension pairs and we keep in RAM the String Graph for the subset of reads in  $R$ for which at least a $q'$-interval is in a terminal extension pair computed so far.  More precisely, at a given iteration $i$, given $\mathcal{E}_i$  the terminal extension pairs at step $i$, if $R_i$ is the subset of reads which at least a $q'$-interval is in  extension pair of
$\mathcal{E}_i$, then the algorithm produces the String graph over $R_i$ since only extensions that are prefix-free for sets $E(r)$, with $r \in R_i$ have been examined.

Actually, the prefix-free property cannot be tested without knowing the strings associated to the reads in $R_i$.

 However,  we will use the length of the extension as a criteria to test the property ... as detailed  in the procedure \emph{Checkifirreducible}....





Observe that each edge  $(r, r_e)$ in a String graph over  $R$ is associated to a terminal extension pair as follows:

- \notaestesa{Paola}{spiegare}

The correctness of our approach relays on the fact that all possible terminal extension pairs will be examined during the iterations and thus the arc-set of the final String graph over  $R$ will be computed.


The String-graph is memorized in RAM  as a list of arcs.... \notaestesa{Paola}{qua va detto come è memorizzato il grafo e si accede agli archi}


\section*{The  algorithm}


The main step of our algorithm consists in building efficiently using external memory  the $Q$-intervals on $B$ and the $rev(Q)$-intervals on $B'$ of increasing length $l$, by means of sequential iterations where the first iteration starts from a minimum value $\tau$ for the length $l$. Each iteration increases by one the length $l$, till the maximum length of a read in $R$ is reached and each iteration uses the main functions of the FM-index, $Occ$ and $C$, detailed before. The computation of  $Q$-intervals on $B$ and the $rev(Q)$-intervals on $B'$ is used to compute for each read $r$ arc set $A_r$ whenever they are produced by the processing of all $Q$-intervals and $rev(Q)$-intervals.
In fact,  by mens of $Q$-intervals and $rev(Q)$-intervals, at each iteration  we can compute a set of reads inducing maximum overlaps with a given read $r$  and  which is $R$-irreducible, whenever
the iteration allows to infer $A_r$. The novel idea, is that of mantaining the information of  maximum overlaps between all pair of reads as well as of the extension sets: both informnation produces the list of arcs.



Our algorithm is based on the two methods presented in \cite{Bauer2011, Cox2012}. The first one builds the BWT of a collection of strings using  $|\Sigma|$ external files, each one containing the BWT segment related to suffixes starting with the symbol $\sigma$. The second method allows to construct (in external files) BWT intervals of increasing length.

\notaestesa{Paola}{va detto qualcosa di più almeno nell'introduzione sull'uso della memoria interna}.
In particular, the procedure \emph{processInterval} given in \cite{Cox2012} is used in our algorithm to produce the sorted list (lexicographical order) of the intervals of a given length $l$, from the sorted list of the intervals of length $l-1$ (intervals of length $1$ can be easily obtained by means of the FM-index function $C$).

In the paper we extend the above approach in the  procedure  \emph{processJoinedInterval} in order to produce during the same iteration the sorted list of $Q$-intervals linked to $rev(Q)$-intervals of length $l$, given the ones of length $l-1$ on the two BWT's $B$ and $B'$.

More precisely, the procedure works as follows in external memory.  Assume to have the sorted list of $Q$-intervals with the  linked  $rev(Q)$-intervals of length $l-1$    partioned in $|\Sigma|$ external files, each one containing the intervals related to a string starting with the same symbol $\sigma$. Observe that once such list is given, since the BWT $B$ correspond to a lexicographic ordering of all suffixes, then when reading $B$ from left to right, it is  partioned into four $\sigma Q$-intervals corresponding to the ordering of symbols in $|\Sigma|$.
Thus,  we can backward extend each  $Q$-interval that we read in a given file produced at step $l-1$ while reading consecutively the values in the file reporting $B$ (respectively $B'$). Each sorted backward extension
$\sigma Q$ and thus the linked $rev(Q)$-interval, is obtained by by counting the values that are equal to $\sigma$ (let us recall that such values are the ones that precede $Q$ in the lexicographic ordering of the $\sigma Q$-interval).
More precisely, the steps ....  in algorithm \emph{processJoinedInterval}  directly provides the values of the new $\sigma Q$-interval and such value is appended at the end of the new updated list (or file), in order to mantein the lexicographic ordering. In fact, the sorted property of the file, allows to update the files while reading the files themself, thus minimizing the  operations on the file.
\notaestesa{Paola}{nota bene il passo dal 3 al 9 non si capisce come sia implementato in termini di memoria esterna ed interna - io sarei per descrivere la procedura  processJoinedInterval-
dettagliandola rispetto ai linked intervals, che però vanno definiti prima, in termini costruttivi}.


Let us now detail the main procedure \emph{buildGraph$(G, \tau)$} that builds the arc-set of the string-graph. Based upon the procedure \emph{processJoinedInterval}, we give two main procedures that give the iteration step of \emph{buildGraph$(G, \tau)$} we detail below. Observe that we describe the algorithm as building three main lists, that are actually implemented by files that are read once from left to right.



At the beginning, an empty set $R_r$ is initialized for each $r \in R$.  At each iteration $j$ (starting from $j=0$), the following lists are used,
\begin{itemize}
\item $\mathcal{Q}_j$, containing the $Q$-intervals $[b, e)$ on $B$ of width $>1$ and length $(j+\tau)$, each one with its linked $rev(Q)$-interval $[b', e')$ on $B'$.
\item $\mathcal{T}$, containing the $rev(Q)$-intervals $[b', e')$ of length $(j+\tau)$ which are $P$-intervals, each one with its dimension $n$.
\item $\mathcal{E}_j$, containing the extension pairs $(q'', q')$ of dimension $(j+\tau)$, each one with its extension $e$ $> 0$
\end{itemize}

Observe that the $j$-iteration will produce  $\mathcal{Q}_{j+1}$,  $\mathcal{E}_{j+1}$ that will be used in the next $j+1$-iteration.

Intervals $[b,e)$ in $\mathcal{Q}_j$ represent common strings $Q$ of length $(j+\tau)$.
Their link to the $rev(Q)$-interval $[b',e')$ on $B'$ is easily maintained (during the backward extension of the intervals of length $(j+\tau-1)$ to produce the intervals in $Q_j$) by using the formula in (??). This list is partioned into $|\Sigma|$ files according to the starting symbol of $Q$, and maintained sorted by ascending value of the start $b$.

A $rev(Q)$-interval  $[b',e')$ in $\mathcal{T}$ represents common strings $Q$ of length $(j+\tau)$ occurring $n$ times as a prefix in $R$. Recall that the interval $[b',b'+n)$ represents the reads having $Q$ as a prefix.


The seeds of the extension pairs in $\mathcal{E}_j$
%(partioned in $|\Sigma|$ files according to the first symbol of ??)
have a length $< (j+\tau)$ and are the common substrings considered at the previous iterations $< j$.
\notaestesa{Paola}{a me sembra che al passo $j$ la lunghezza sia $< =< (j+\tau)$- ricontrollare bene}

\noindent
{\bf Iteration $j = 0.$}

At the first iteration $j=0$, the list $\mathcal{Q}_0$ contains the common substrings of length $\tau$, and $\mathcal{E}_0$ is empty. The iteration steps end when both $\mathcal{Q}_j$ and $\mathcal{E}_j$ are empty.

\noindent
{\bf Iteration $j > 0.$}

During the $j$-th iteration, each $Q$-interval $[b, e)$ on $B$ (and the linked $rev(Q)$-interval on $B'$) in $\mathcal{Q}_j$ is backward extended in order to compute (i) the list $\mathcal{Q}_{j+1}$ of the intervals of length $(j+\tau+1)$, and (ii) the list $\mathcal{T}$ of the \emph{P-intervals} of length $(j+\tau)$.
The list $\mathcal{Q}_{j+1}$ will be used during the next iteration $(j+1)$, and represents common strings of length increased by $1$. The list $\mathcal{T}$ is computed by taking into account that a \emph{P-interval} $[b', e')$ with dimension $n$ is linked to a $Q$-interval $[b, e)$ with exactly $n$ extensions with the symbol $\$$.
The list $\mathcal{T}$ must be sorted by ascending value of the starting value $b'$ (\ie lexicographical order of $rev(Q)$). In fact, let us recall that a \emph{P-interval} $[b', e')$  correspond to the ordered list of  reads having substring $rev(Q)$ on $B'$.   Then, each \emph{P-interval} $[b', e')$ of dimension $n$ and each interval $[b', b'+n)$ in the list $\mathcal{T}$ (the latter representing the set of the reads having string $Q$ as a prefix) are backward extended in order to compute the extension pairs $(q'', q')$ with dimension $(j+\tau+1)$ and extension $1$, to put into the list $\mathcal{E}_{j+1}$ to use during the next iteration $(j+1)$. More in detail, given a \emph{P-interval} $[b',e')$ and its sub-interval $[b',b+n)$, a pair $(q'',q')$ of extension $e=1$ is added for each $q'' \in X(b',b'+n)$, where $q'$ is the $\$$-interval obtained by extending $[b',e')$. Notice that the interval $[b', b'+n)$ (under our assumption) cannot have extensions with symbol $\$$: in fact, no read in $R$ can have $Q$ both as a prefix and a suffix.

At each iteration $j$, the interval $q''$ of a pair $(q'', q')$ with extension $e$ in $\mathcal{E}_j$ is backward extended on $B'$, where $q''$ is given. Observe that each $\sigma$  backward extension corresponds to forward extend by $\sigma$ on $B$ the  \$ $Q$-intervals, i.e. computing the interval of reads having $Q \sigma$ has prefix (see figure \ref{}).


If $q''$ has a (unique under our assumption) extension with symbol $\$$ into the interval $[b'_r, b'_r+1)$, then the read represented by that interval is added to the arc-set of each read represented by the interval $q'$ (and no extension pair is added to $\mathcal{E}_{j+1}$).
\notaestesa{Paola}{qua occorre dire il perchè} In fact, it means that ....

Such arc-sets are checked, in order to guarantee their \emph{irreducibility}.
\notaestesa{Paola}{questa parte è da rivedere ... cosa si intende per irriducibilità?}
Notice that just $(j+\tau)$-long reads are added to arc-sets at the $j$-th iteration.\\
Otherwise (if $q''$ has no extension with symbol $\$$), an extension pair $(q_e, q')$ (of dimension $(j+\tau+1)$ and extension $e+1$) is added to the list $\mathcal{E}_{j+1}$, for each $q_e \in X(q'')$, where $X(q'')$ is the set of the intervals obtained by backward extending $q''$ with each $\sigma \in \Sigma$.

At each iteration $j$, the list $\mathcal{E}_{j+1}$ receives extension pairs both from $\mathcal{T}$ and $\mathcal{E}_{j}$. Since, the length of the intervals $[b', b'+n)$ in $\mathcal{T}$ is equal to the length of intervals $q''$ in $\mathcal{E}_{j}$, the algorithm can extend the union of the two lists, and therefore keep sorted also the list $\mathcal{E}_{j+1}$, by ascending value of the start of the interval $q''$ on the BWT $B'$.

\section*{Pseudocode}

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

\Input{$R$, a collection of reads,\\$\tau$, a parameter}
\Output{the String Graph of $R$}

\tcp{Get the collection of the reverse of the reads}
$R' \gets rev(R)$\;
$B \gets BWT(R)$\;
$B' \gets	BWT(R')$\;

%\tcp{Get the $Q$-intervals on $B$ (of width $> 1$) \st $|Q|=\tau$, and the related $rev(Q)$-intervals on $B'$}
$\mathcal{Q}_{0} \gets$ $Q$-intervals of length $\tau$ and width $>1$\;
$\mathcal{E}_0 \gets \emptyset$\;

\ForEach{$r \in R$}{
$R_r \gets \emptyset$\;
}

$j \gets 0$\;

\While{$(\mathcal{Q}_j \cup \mathcal{E}_j) \ne \emptyset$}{
  ($\mathcal{Q}_{j+1}$, $\mathcal{T}) \gets extendQOnLeft(\mathcal{Q}_j, B)$\;
  sort $\mathcal{T}$\;
  $\mathcal{E}_{j+1} \gets extendQOnRight(\mathcal{T}, \mathcal{E}_j, B')$\;
%  \ForEach{$r \in R$}{
%    make $R_r$ \emph{irreducible}\;
%  }
  $j \gets j+1$\;
}

$A \gets \emptyset$\;
\ForEach{$r \in R$}{
 \ForEach{$r' \in R_r$}{
  $A \gets A \cup \{(r,r')\}$\;
 }
}

\Return{$(R, A)$}\;

\caption{buildGraph($R$, $\tau$)}
\label{alg:build-graph}

\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{algorithm}
%\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
%
%\Input{$B$, the BWT of $R$,\\ $t$, the length of the returned BWT intervals}
%\Output{$I_t$, the sorted list of the BWT intervals of length $t$ and width $>1$}
%
%$k \gets 1$\;
%$I_k \gets$ empty list\;
%%Create $|\Sigma|$ files $I_k(\sigma)$, for each $\sigma \in \Sigma$\;
%\For{$i \gets 1$ \KwTo  $|\Sigma|$}{
%  $b \gets C_T(\sigma_i)$\;
%  $e \gets C_T(successor(\sigma_i)$\;
%  \If{$(e-b) > 1$}{
%    Append $\langle [b,e),[b,e), \sigma_i \rangle$ to $I_k(\sigma_i)$\;
%  }
%}
%
%\For{$k \gets 2$ \KwTo  $t$}{
%  %Open $|\Sigma|$ files $I_k(\sigma)$, for each $\sigma \in \Sigma$\;
%  $I_k \gets$ empty list\;
%  Inizialize vector $\Pi \gets [0, 0, . . . , 0]$ of $|\Sigma|$ integers\;
%  \For{$i \gets 1$ \KwTo  $|\Sigma|$}{
%     \ForEach{$\langle [b,e),[b',e'), \sigma^* \rangle \in I_{k-1}(\sigma_i)$}{
%        $L \gets processJoinedInterval([b,e),[b',e'),B,\Pi)$\;
%        \For{$p \gets 1$ \KwTo  $|\Sigma|$}{
%	  $\langle [b_p,e_p),[b'_p,e'_p)\rangle \gets L[p]$\;
%	  \If{($e_p-b_p)>1$}{
%	     Append $\langle [b_p,e_p),[b'_p,e'_p), \sigma^* \rangle$ to $I_k(\sigma_p)$\;
%	   }
%         }
%    }
%  }
%  Delete $I_{k-1}$\;
%}
%
%\Return{$I_t$}\;
%
%\caption{getQIntervals($B$, $t$)}
%\label{alg:get-intervals}
%\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

\Input{$\mathcal{Q}$, the sorted list of the $Q$-intervals on $B$ of a given length $l$\\$B$, the BWT of $R$}
\Output{$\mathcal{Q}_{e}$, the sorted list of the BWT intervals of length $l+1$,\\$\mathcal{T}$, the list of the prefix intervals of length $l$}

$\mathcal{Q}_{e} \gets \emptyset$\;
$\mathcal{T} \gets \emptyset$\;

Inizialize vector $\Pi \gets [0, 0, . . . , 0]$ of $|\Sigma|$ integers\;

 \For{$i \gets 1$ \KwTo  $|\Sigma|$}{
      \ForEach{$\langle [b,e),[b',e')\rangle \in \mathcal{Q}(\sigma_i)$}{
	$L \gets processJoinedInterval([b, e),[b', e'),B,\Pi)$\;
         \tcp{Check the $\$$-extension}
	$\langle ([b_1,e_1),[b'_1,e'_1)\rangle \gets L[1]$\;
	\If{$(e_1 - b_1) > 0$}{
	   $n \gets (e_1 - b_1)$\;
            Append $\langle [b', e'), n\rangle$ to $\mathcal{T}$\;
	}

        \For{$p \gets 1$ \KwTo  $|\Sigma|$}{
	  $\langle [b_p,e_p),[b'_p,e'_p)\rangle \gets L[p]$\;
	  \If{($e_p-b_p)>1$}{
	     Append $\langle [b_p,e_p),[b'_p,e'_p)\rangle$ to $\mathcal{Q}_{e}(\sigma_p)$\;
          }
        }
     }
}

\Return{$\mathcal{Q}_{e}$, $\mathcal{T}$}\;

\caption{extendQOnLeft($\mathcal{Q}$, $B$)}
\label{alg:extend-left}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{$\mathcal{T}$, the sorted list of the $P$-intervals of a given length $l$,\\$\mathcal{E}$, the sorted list of the extension pairs of dimension $l$,\\$B'$, the BWT of the reversed set $R'$}
\Output{$\mathcal{E}_{e}$, the sorted list of the extension pairs of dimension $(l+1)$}

$\mathcal{E}_{e} \gets \emptyset$\;

Inizialize vector $\Pi \gets [0, 0, . . . , 0]$ of $|\Sigma|$ integers\;

    \While{$(\mathcal{T} \cup \mathcal{E}) \neq \emptyset$} {
             $\langle [b', e'), n \rangle \gets pop((\mathcal{T})$\;
             $\langle [b'_p, e'_p), [b'_s,e'_s), e \rangle \gets pop(\mathcal{E})$\;
		\If{$(b' < b'_p)$} {
			$push(\mathcal{E}, \langle  [b'_p, e'_p), [b'_s,e'_s), e \rangle)$\;
			$L \gets processInterval([b', e'), B', \Pi)$\;
                           $[b'_{s}, e'_{s}) \gets L[1]$\;
			\If{$(e'_{s} - b'_{s}) > 0$} {
                                   $L \gets processInterval([b', b'+n), B', \Pi)$\;

				\For{$i \gets 2$ \KwTo $|\Sigma|$} {
                                             append $\langle L[i], [b'_{s}, e'_{s})\rangle$ to $\mathcal{E}_e(\sigma_i)$ if $L[i]$ is not null\;
				}
			}
		}
		\Else {
			$push(\mathcal{T}, \langle  [b', e'), n \rangle)$\;
                           $L \gets processInterval([b'_p, e'_p), B', \Pi)$\;
                           $[b'_{p\$}, e'_{p\$}) \gets L[1]$\;
			\If{$(e'_{p\$} - b'_{p\$}) > 0$} {

			   \ForEach{$r \in R(b'_s,e'_s)$}{
          			$r_e \gets R(b'_{p\$}, e'_{p\$})$\;
				$checkIfIrreducible(r, r_e, e)$\;
                             }
			}
			\Else {
				\For{$i \gets 1$ \KwTo $|\Sigma|$} {
					$[b_a, e_a) \gets updateBwd([b, e), \sigma_k, \Pi, \pi, B')$\;
					\If{$(b_a < e_a)$} {
						Append($\langle L[i], [b'_s, e'_s), e+1 \rangle$) to $\mathcal{E}_e(\sigma_i)$ if $L[i]$ is not null\;
					}
				}
			}
		}
	}

\Return{$\mathcal{E}_{e}$}\;

\caption{extendOneStepRight($\mathcal{T}$, $\mathcal{E}$, $B'$)}
\label{alg:extend-right}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

\Input{$[b,e)$, a $Q$-interval on a BWT $B$,\\$[b',e')$, the linked $rev(Q)$-interval on $rev(B)$,\\$B$, the BWT of a collection of strings,\\$\Pi$, a vector of $|\Sigma|$ integers}
\Output{$L$, the list of the extended intervals on $B$, each one with its linked interval on $rev(B)$}

Update $\Pi$ such that $\Pi[i]$ is the number of $\sigma_i$ in $B[0,b)$\;
Create a vector $\pi$ of $|\Sigma|$ integers \st $\pi[i]$ is the number of $\sigma_i$ in $B[b,e)$\;


$L \gets \emptyset$\;
$\pi sum \gets 0$\;
\For{$i \gets 1$ \KwTo  $|\Sigma|$}{
   $b_i \gets C_T(\sigma_i)+ \Pi[i]$\;
   $e_i \gets b_i + \pi[i]$\;
   $b'_i \gets b'+ \pi sum$\;
   $e'_i  \gets b'_i + \pi[i]$\;
   Append $\langle [b_i, e_i), [b'_i, e'_i)\rangle$ to L\;
   $\pi sum \gets \pi sum + \pi[i]$\;
}

\tcp{Update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B[0,e)$}
$\Pi \gets \Pi+\pi$\;

\Return{$L$}\;

\caption{processJoinedInterval($[b,e)$,$[b',e')$, $B$, $\Pi$)}
\label{alg:process-joined-interval}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

\Input{$[b,e)$, a $Q$-interval on a BWT $B$,\\$B$, the BWT of a collection of strings,\\$\Pi$, a vector of $|\Sigma|$ integers}
\Output{$L$, the list of the extended intervals on $B$}

Update $\Pi$ such that $\Pi[i]$ is the number of $\sigma_i$ in $B[0,b)$\;
Create a vector $\pi$ of $|\Sigma|$ integers \st $\pi[i]$ is the number of $\sigma_i$ in $B[b,e)$\;

$L \gets \emptyset$\;
\For{$i \gets 1$ \KwTo  $|\Sigma|$}{
   $b_i \gets C_T(\sigma_i)+ \Pi[i]$\;
   $e_i \gets b_i + \pi[i]$\;

   Add $[b_i, e_i)$ to L\;
}

\tcp{Update $\Pi$ \st $\Pi[i]$ is the number of $\sigma_i$ in $B[0,e)$}
$\Pi \gets \Pi+\pi$\;

\Return{$L$}\;


\caption{processInterval($[b,e)$, $B$, $\Pi$)}
\label{alg:process-interval}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{$r_1$, a read,\\$r_2$, a read extending $r_1$,\\$e$, the extension length of $r_2$ \wrt $r_1$}
\Output{}

$adjList \gets getAdjList(r_1)$\;
\If{$adjList = \emptyset$} {
	append($r_2, e$) to $adjList$\;
}
\Else {
	$(r_a, e_a) \gets adjList[0]$\;
	\If{$e < e_a$} {
                 $adjList \gets \emptyset$\;
		Append($r_2, e$) to $adjList$\;
	}
}

\caption{checkIfIrreducible($r_1, r_2, e$)}
\end{algorithm}

\section{On the complexity}


------ricordarsi la questione del fatto che usando un  dollaro unico per tutti i reads si perde l'ordiamento  dei reads  -----



Given a set of reads $R$ of cardinality $n$, let $l$ be the maximal length of a read in $R$.

% and let us recall that $n$ is the total number of reads ($R$)

The time complexity for building the BWT of the collection $R$ of reads is the one reported in the paper ((Lightweight BWT Construction for Very Large String Collections)).

More precisely, using BCR we can build the data structure in $\mathcal{O}(l\times sort(n))$ whereas using BCRext the time complexity is $\mathcal{O}(ln)$.

Observe that the buildgraph procedure  consists of iterating at most $l$ times the procedures
ExtendQonLeft and ExtendQonRight. In fact, those two procedures
%the procedures ExtendQonLeft and ExtendQonRight
apply the backward extension to every $Q$-interval in $\mathcal{Q}_j$ at most $l$ times, since there can't be any interval related to a pattern $Q$ such that $|Q| > l$. % $Q$-interval has length at least $\tau$.

On the other hand the procedures ExtendQonLeft and ExtendQonRight aim to build all the possible $Q$-intervals linked to the maximal overlaps between the reads (the irreducible edges of the SGR graph) by means of an incremental approach that rely on the computation of the $Q$-intervals during the previous steps.

Thus, the time complexity of these procedures may be measured by considering the total number of possibile $Q$-intervals that we have to compute for every length of $Q$ (more precisely for $|Q| \in \{1 \dots l\}$).
% the fact that after the total number of iterations they have extended at most all possible $Q$-intervals in the data set $R$ for $|Q| \in \{1 \dots l\}$.

Then the total  complexity of ExtendQonLeft and ExtendQonRight is at most $\mathcal{O}(N_Q)$, where $N_Q$ is the total number of $Q$-intervals (i.e. distinct substrings of $R$).

An estimate of $N_Q$ can be given as $O(l \times n)$ (let us recall that the number of distinct strings in a word on length $x$ is  at most $x$  ((Trovare articolo e citare))).

Note that during the iteration step the buildgraph procedure has also to sort $\mathcal{T}$. Recall that, at a given iteration $i$, $\mathcal{T}$ is the set of $Q$-intervals such that $Q$ is prefix for at least one read and $|Q| = i + \tau$; it's fairly clear that $|\mathcal{T}| \leq n$. This procedure has a total time complexity $\mathcal{O}(l \times sort(n))$.

Hence the time complexity for building the string graph is $\mathcal{O}(l \times (n + sort(n)))$. % of BWT in external memory and thus an estimate of the time over real data can be ....



\section{Conclusion and future work}
------
The above  notion of String Graph applies to   assembling RNA-seq data into splicing graph \cite{Beretta2013}.
When assembling RNA-seq data with an overlap graph, the final output graph is not a line path, since the graph should represent the alternative transcripts derived by the alternative splicing
on the gene structure. In fact, RNA-seq data are classified into {\em spliced} and  {\em  unspliced} reads. Unspliced reads are reads that cover regions that are either coding or not coding ones, i.e. they are absent or present in a transcript sequence. On the contrary a  spliced read $r$ contains  of  at least two consecutive substrings   $r_i $, $r_{i+1}$ such that  there exists at least two transcripts where  $r_i$ is present in a transcript sequence  together with $r_{i+1}$ while $r_i$ is present and $r_{i+1}$ is absent in the transcript sequence.

In order to include this case we give a more general notion of irreducible edges of an overlap graph. Under the assumption that a read is not included in another one, the transitive reduction of an overlap graph, by which we get a string graph from an overlap graph, corresponds to require that the set of reads that extends a read $r$ is irreducible. This definition includes also the case of  splicing graphs...

\bibliographystyle{splncs03}
\bibliography{biblioBWTpaper}


\end{document}
